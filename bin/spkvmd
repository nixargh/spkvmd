#!/usr/bin/env ruby
# encoding: utf-8
# small personal kvm daemon
# (*w)
VERSION = "0.1.0"
##### SETTINGS #####################################################
$params = nil
$kvm_vm_list = nil
@conf_dir = 'config' # config directory
@bin_dir = 'bin' # binary directory
@conf_file = 'spkvmd.conf' # config file name
##### REQUIRE ######################################################
##### MODULES ######################################################
##### FUNCTIONS ####################################################
def os? # detect OS
	if RUBY_PLATFORM.downcase.include?("linux")
		$os = 'linux'
	elsif RUBY_PLATFORM.downcase.include?("darwin")
		$os = 'macos'
	else
		ENV['OS'].downcase.include?("windows_nt") ? ($os = 'windows') : ($os = 'unknown')
	end
end

def get_program_root_dir! # detect program root directory
        $prog_dir = File.expand_path(File.dirname(__FILE__)).gsub!("/#{@bin_dir}",'')
end

def read_conf! # read configuration file
	if Dir.exist?(@conf_dir)
        	conf_file = $prog_dir + '/' + @conf_dir + '/' + @conf_file
		if File.exist?(conf_file)
			params = Hash.new
			IO.read(conf_file).each_line{|line|
				comment_index = line.index('#')
				line = line[0..comment_index-1] if comment_index
				line.chomp!
				sline = line.split('=')
				params[sline[0]] = find_bool(sline[1].strip)
			}
			puts params if params['debug'] 
			$params = params
		else
			raise "Configuration file (#{conf_file}) not found!"
		end
	else
		raise "Config directory (#{@conf_dir}) not found!"
	end
end

def find_bool(string) # convert string to boolean
	if string == 'true'
		true
	elsif string == 'false'
		false
	else
		string
	end
end

##### CLASSES ######################################################
class SPKVMD # main class
	def start_Listner!
		Thread.new do
			listner = Listner.new
			listner.accept_sessions!
		end
	end

	def start_Watcher!
		Thread.new do
			Watcher.start!
			#Watcher.new
		end
	end

	def wait_all!
		Thread.list.each{ |thr| thr.join if thr != Thread.current }
	end
end

class Listner # class to operate with TCP Server
	def initialize
		begin
			puts "Starting SPKVMD Listner..."
			require 'socket'
			@server = TCPServer.new($params['tcp_addr'],$params['tcp_port'])
		rescue
			raise "Can't create new TCPServer: #{$!}"
		end
	end

	def accept_sessions! # start new thread for each connection
		loop do
			Thread.abort_on_exception=true
			Thread.start(@server.accept) do |session|
				Session.new(session)
				session.close
				puts "\t[#{Thread.current}] - session closed"
			end
		end
	end
end

class Watcher # class to operate with Virtual Machines list
	def self.start!
		begin
			puts "Starting SPKVMD Watcher..."
			@kvm = KVM.new if !@kvm
			loop do
				self.refresh!
				#puts "\t#{Time.now} - [KVM_VM_UPDATER] KVM VM list updated."
				sleep $params['refresh_time'].to_i
			end
		rescue
			raise "Can't create new Watcher: #{$!}"
		end
	end

	def self.refresh!
		@kvm = KVM.new if !@kvm
		$kvm_vm_list = @kvm.get_vm_list 
	end
end

class Session # class to work with sessions
	def initialize(session)
		@current_lvl = 'ROOT'
		@previous_lvl = nil
		@session = session
		begin
			puts "\t[#{Thread.current}] - session opened"
			@session.puts("-= spkvmd welcome you =-")
			loop do
				puts_to_c(nil)
				cmd, arg = read_s
				if cmd == 'quit'
					break
				elsif cmd == 'kvm'
					operate_kvm
				elsif cmd == 'ks'
					exit
				else
					puts_to_c('Unknown command')
				end
			end
		rescue
			puts "session initialize error: #{$!}"
		end
	end

private

	def read_s # format input from session
		@session.gets.chomp.split(' ', 3)
	end

	def operate_kvm # KVM operations
		chlvl!('KVM_OPERATOR')
		puts "\t\t[#{Thread.current}] - enter #{@current_lvl}"
		puts_to_c(nil)
		begin
			kvm = KVM.new
			loop do
				cmd, vm, arg = read_s
				if cmd == 'back'
					return_to_lvl!
					puts "\t\t[#{Thread.current}] - exit #{@previous_lvl}"
					break
				elsif cmd == 'list'
					vm_list = $kvm_vm_list
					puts "\t\t\t[#{Thread.current}] - #{vm_list.length} vms listed to client."
					puts_to_c(vm_list)
				elsif cmd == 'flist'
					Watcher.refresh!
					vm_list = $kvm_vm_list
					puts "\t\t\t[#{Thread.current}] - List updated. #{vm_list.length} vms listed to client."
					puts_to_c(vm_list)
				elsif cmd == 'start'
					operation(vm, cmd){|i| kvm.start(i) }
				elsif cmd == 'stop'
					operation(vm, cmd){|i| kvm.stop(i) }
				elsif cmd == 'pause'
					operation(vm, cmd){|i| kvm.pause(i) }
				elsif cmd == 'resume'
					operation(vm, cmd){|i| kvm.resume(i) }
				elsif cmd == 'console'
					begin
						puts "\t\t\t[#{Thread.current}] - \"#{arg}\" command sended to VM=#{vm} console."
						responce = kvm.console(vm, arg)
						puts "\t\t\t[#{Thread.current}] - VM=#{vm} return \"#{responce}\" to \"#{arg}\" command."
						puts_to_c("#{vm} - #{responce}")
					rescue
						error = $!
						puts "\t\t\t[#{Thread.current}] - Can't connect to VM=#{vm} console: #{error}."
						puts $!.backtrace
						puts_to_c("#{vm} - failed to connect to console: #{error}")
					end
				else
					puts_to_c('Unknown command')
				end
			end
		rescue
			puts "KVM_OPERATOR error: #{$!}"
			puts $!.backtrace
		end
	end

	def operation(vm, o_name) # do 'yield' operation with 'vm' and talk about it as about 'o_name'
		begin
			yield(vm)
			if (i = o_name.rindex('e'))
				o_name.slice!(i) if i == o_name.length - 1
			elsif (i = o_name.rindex('p'))
				o_name = o_name + 'p' if i == o_name.length - 1
			end
			puts "\t\t\t[#{Thread.current}] - VM=#{vm} #{o_name}ed."
			puts_to_c("#{vm} - #{o_name}ed")
			Watcher.refresh!
		rescue
			error = $!
			puts "\t\t\t[#{Thread.current}] - Can't #{o_name} VM=#{vm}: #{error}."
			puts_to_c("#{vm} - failed to #{o_name}: #{error}")
		end
	end

	def puts_to_c(string) # formated output to session
		@session.puts("[#{@current_lvl}]: #{string}")
	end

	def chlvl!(new_lvl) # changing current menu level
		@previous_lvl = @current_lvl
        @current_lvl = new_lvl
	end

	def return_to_lvl! # returning to previos menu level
		a = @current_lvl
		@current_lvl = @previous_lvl
		@previous_lvl = a
	end

end

class KVM # class to work with KVM
	def initialize
		raise "kvm or vm_dir not configured" if !$params['kvm'] || !$params['vm_dir']
		if File.exist?($params['kvm'])
			@kvm_bin = $params['kvm']
		else
			raise "kvm binary not found"
		end
		if Dir.exist?($params['vm_dir'])
			@vm_dir = $params['vm_dir']
		else
			raise "virtual machines directory not found"
		end
	end

	def list # list virtual machines
		get_vm_list
	end

	def info(vm) # information about virtual machine
	end

	def start(vm) # start virtual machine
		vm_info = $kvm_vm_list[vm]
		if (status = vm_info['status']) == 'stopped'
			result = nil
			start_script = "#{$params['vm_dir']}/#{vm}/#{$params['start_script']}"
			start_cmd =  read_start_script(start_script)
			IO.popen([*start_cmd, :err=>[:child, :out]]){|io|
				result = io.readlines
			}
			result == [] ? (return true) : (raise result.to_s)
		else
			raise "VM status = \"#{status}\""
		end
	end

	def stop(vm) # stop virtual machine
		vm_info = $kvm_vm_list[vm]
		if (status = vm_info['status']) != 'stopped'
			Process.kill(15, vm_info['pid'])
			File.delete(vm_info['pid_file']) if vm_info['pid_file']
		else
			raise "VM status = \"#{status}\""
		end
	end

	def pause(vm)
		if (result = console(vm, 'stop')) == []
			return true
		else
			raise result
		end
	end

	def resume(vm)
		if (result = console(vm, 'cont')) == []
			return true
		else
			raise result
		end
	end

	def console(vm, cmd) # communicate with VM console (-monitor)
		vm_info = $kvm_vm_list[vm]
		s = UNIXSocket.new(vm_info['socket'])

		s.puts(cmd)
		sleep 0.5
		
		string_responce = read_socket(s)

		s.flush
		s.close
		
		format_responce(string_responce)
	end

	def get_vm_list # get list of VM and different information about them
		vm_list = Hash.new
		read_vm_dir.each{|vm|
			vm_info = Hash.new

			vm_info['status'], vm_info['pid_file'], vm_info['pid'] = get_process_status(vm)
			vm_info['socket'] = get_socket_file(vm)
			
			vm_list[vm] = vm_info
		}
		vm_list
	end

	def show_config(vm) # show virtual machine configuration
	end
	
	def edit_config(vm) # edit virtual machine configuration
	end

private
	
	def read_socket(socket)
		string_responce = String.new
		while output = socket.recv(128) do
			string_responce << output
			break if string_responce.scan("(qemu) ").count == 2
		end
		string_responce
	end

	def format_responce(string)
		new_string = (string.split("(qemu) "))[1]
		responce = Array.new
		c = 0
		new_string.each_line{|line|
			c += 1
			responce.push(line.chomp.strip) if c > 1
		}
		responce
	end

	def read_vm_dir # read subdirectories from virtual machines root directory
		vm_array = Dir.entries($params['vm_dir'])
		vm_array.delete('.')
		vm_array.delete('..')
		vm_array
	end

	def get_process_status(vm) # find pid file, pid and detect status of VM
		pid_file = "#{$params['vm_dir']}/#{vm}/#{$params['pid_file']}"
		status = 'stopped'
		if File.exist?(pid_file) 
			pid = IO.read(pid_file).chomp.to_i
			pid_stat_file = "/proc/#{pid}/statm"
			if Dir.exist?('/proc')
				if File.exist?(pid_stat_file)
					if IO.read(pid_stat_file).split(' ')[2] != 'Z'
						if $kvm_vm_list
							status = (console(vm, 'info status')[0].split(': '))[1]
						else
							status = 'running (maybe paused)'
						end
					end
				else
					File.delete(pid_file)
					pid_file = nil
					pid = nil
				end
			else
				raise "proc directory not found. Is it Linux?"
			end
		else
			pid_file = nil
			pid = nil
		end
		return status, pid_file, pid
	end

	def get_socket_file(vm) # detect socket file
		socket_file = "#{$params['vm_dir']}/#{vm}/#{$params['socket_file']}"
        File.socket?(socket_file) ? socket_file : nil
	end

	def read_start_script(file) # read script that start virtual machine from virtual machine folder
		start_cmd = nil
		IO.read(file).each_line{|line|
			if line.index('#') != 0
				start_cmd = line.delete('&')
				start_cmd = start_cmd.split(' ')
				break
			end
		}
		start_cmd ? start_cmd : raise("VM starting string not found")
	end

end
##### PROGRAM ######################################################
begin
	if os? == 'linux'
		get_program_root_dir!
		read_conf!
		spkvmd = SPKVMD.new
		spkvmd.start_Watcher!
		spkvmd.start_Listner!
		spkvmd.wait_all!
	else
		raise "Only for Linux"
	end
rescue
	puts $!
end
